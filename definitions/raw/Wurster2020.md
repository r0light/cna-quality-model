# Cloud-native apps characteristics 

Wurster, M.; Breitenb√ºcher, U.; Brogi, A.; Leymann, F. & Soldani, J.
Cloud-native Deploy-ability: An Analysis of Required Features of Deployment Technologies to Deploy Arbitrary Cloud-native Applications 
Proceedings of the 10th International Conference on Cloud Computing and Services Science, SCITEPRESS - Science and Technology Publications, 2020

**C1: Service-based Architectures**. Cloud-native applications are designed as suites of loosely coupled (micro)services. Each service exists independently from the other services forming an application, hence allowing their independent development and operation (Kratzke and Quint, 2017). At the same time, a service typically interacts with other services in an application, which are discovered by exploiting features provided by the application runtime (Pivotal Software, Inc., 2019). This allows to compose services and form cloudnative applications.

**C2: API-based Interactions**. Service-to-service communications in cloud-native application are API-based. The services forming an application indeed publish APIs to offer their functionalities, and they connect to and consume the APIs of other services in the application (Vettor and Smith, 2019). APIs are typically based on well-known standard protocols (e. g., REST over HTTP), and each component in a cloud-native application should be encapsulated by offering its API (Janssen, 2018; Vettor and Smith, 2019).

**C3: State Isolation**. Cloud-native applications are designed with a clear separation among stateless and stateful services. Stateless services exist independently from stateful services, even if interacting with them, making them easy to scale in/out. Stateful services instead follow a different pattern for assuring higher availability and resiliency of persisted data (Fehling et al., 2014). This is done by typically exploiting natively scalable storage systems in the form of eventual consistent NoSQL databases (Kratzke and Quint, 2007).

**C4: Self-contained Service Deployment**. The services forming a cloud-native application are packaged in standardized, self-contained deployment units (Red Hat, Inc., 2019). Deployment units wrap services in virtual runtime environments containing everything services need to run, i. e., their source code and necessary runtime support (system tools, system libraries, etc.). This guarantees isolation among services running in different deployment units, and that they will always run the same, independently from the execution environment, whether it is on-premise or on thirdparty clouds, or whether it is a development, testing, or production environment (Janssen, 2018). Currently, beside PaaS and FaaS, containerization is a key enabler for self-contained deployment of the services in a cloud-native application (Kratzke and Quint, 2017; Pahl et al., 2019).

**C5: Disposability**. The actual instances of the services forming a cloud-native application are disposable (Vettor and Smith, 2019). This is a prerequisite for favoring both fast startups and scalability of services and graceful shutdown for leaving applications in correct state, which are both peculiar properties of cloud-native applications. Currently existing container-based technologies inherently satisfy this requirement (Pivotal Software, Inc., 2019; Pahl et al., 2019).

**C6: Fault-resilience**. Failures are first-class citizens in cloud application deployment and management (Brogi et al., 2018), hence requiring cloud-native applications to treat failures as first-class citizens as well. Cloud-native applications indeed assume that service instances can fail at any time and feature mechanisms ensuring fault-resilience (Kratzke and Quint, 2017; Soldani et al., 2018). The services forming an application are built for tolerating the failure of the other services they interact with, typically by exploiting cloud-native design patterns, e. g., circuit breakers (Vettor and Smith, 2019). At the same time, the platforms exploited for deploying and managing cloud-native applications are suitably configured to automatically recover failed service instances.

**C7: Infrastructure Abstraction**. Cloud-native application abstract from underlying infrastructure and operating system dependencies, by operating at a higher abstraction level (Janssen, 2018; Pivotal Software, Inc., 2019). An enabler in this direction is the exploitation of above mentioned self-contained deployment units, which allow to distribute the services of an application over multiple, heterogeneous clouds (Kratzke and Quint, 2017). This is typically achieved by exploiting self-service deployment platforms, allowing to ship and scale deployment units on IaaS or PaaS clouds (Red Hat, Inc., 2019).

**C8: Infrastructure as Code**. Cloud-native applications are highly automated, from their delivery and deployment to their management, scaling, and monitoring (Janssen, 2018; Vettor and Smith, 2019). Such automation is typically achieved using infrastructure as code (Pivotal Software, Inc., 2019), i. e., through machine-readable files allowing to specify the desired configuration for an application and its components (Morris, 2016).

**C9: Policy-driven Elasticity**. Cloud-native applications are horizontally scalable, meaning that each of their services can be scaled in/out, by adapting the amount of replicas (Janssen, 2018). This is done by relying on self-service deployment platforms, which are configured through scaling policies, indicating how to dynamically (re-)allocate computing resources to services, to continuously satisfy the ongoing needs of an application (Pivotal Software, Inc., 2019; Red Hat, Inc., 2019).

**C10: CI/CD Compliance**. Cloud-native applications are developed by embracing continuous integration and continuous deployment/delivery (CI/CD) DevOps paradigm (Kratzke and Quint, 2017). Each service of a cloud-native application is developed in a separate code base and possibly equipped with its own deployment pipeline (Vettor and Smith, 2019). This allows different services to be developed by different teams using different technologies, and to release service updates as soon as they are available, also throughout short and continuous delivery cycles (Janssen, 2018).